/*
Если прозрачный материал может может быть нарисовать поверх сцены, он не может изменить то, что было нарисовано под ним. 
Это означает, что эти Прозрачные шейдеры не могут создавать искажения, такие как те, которые обычно видны в стекле или воде. 
Чтобы имитировать их, нам нужно ввести еще один метод, называемый grab pass. 
Это позволяет нам получить доступ к тому, что было нарисовано на экране до сих пор.

Идея этого эффекта заключается в использовании Vertex и
Fragment Shader с проходом захвата, а затем образец текстуры захвата с небольшим изменением на
его UV-данных для создания искажения


Текстуры шума, которая используется для получения псевдослучайных значений. это
важно, чтобы вы выбрали бесшовную текстуру шума, например, созданные
чередующиеся 2D-шумы Perlin. Это гарантирует, что
материал применяется к большому объекту, вы не увидите никакого разрыва. Для того чтобы
этот э 	ффект для работы, текстура должна быть импортирована в режиме повтора. Если вы хотите
гладкий и непрерывный взгляд, также должны установить его на Bilinear.
*/

Shader "Custom/distortion" {
  Properties  {
    _NoiseTex("Noise text", 2D) = "white" {}
    _Colour ("Colour", Color) = (1,1,1,1)

    _Period ("Period", Range(0, 50)) = 1
    _Magnitude ("Magnitude", Range(0, 1)) = 0.05
    _Scale ("Scale", Range(0, 20)) = 1
  }
  
  SubShader {
    Tags {
      "Queue"="Transparent" 
      "IgnoreProjector"="True" 
      "RenderType"="Transparent"
    }

    ZWrite Off 
    Lighting Off 
    Cull Off 
    Fog { Mode Off } 
    Blend One Zero

    /*
      Проход 1
      Автоматически создает текстуру на которую мы можем ссылаться
      Каждый раз, когда вы используете материал с GrabPass {}, 
      Unity должен отображать экран в текстуре.
      Эта операция очень дорогая и ограничивает количество проходов захвата,
      которые вы можете использовать в игре.

      Эта строка не только позволяет вам указывать имя текстуры, но также делиться текстурой со всеми материалами, 
      которые имеют проход захвата под названием TextureName. 
      Это означает, что если у вас есть десять материалов, 
      Unity будет делать только один проход для захвата и делиться текстурой со всеми из них. 
      Основная проблема этого метода заключается в том, что он не позволяет создавать эффекты,
      которые могут быть сложены. Если вы создаете стакан с помощью этой техники, вы не сможете иметь два стакана один за другим.
    */
    GrabPass { "_GrabTexture" } 
    
    //Проход 2
    Pass {
      CGPROGRAM
      #pragma vertex vert
      #pragma fragment frag
      #pragma target 2.0
      #include "UnityCG.cginc"

      sampler2D _GrabTexture;
      sampler2D _NoiseTex;	
      fixed4 _Colour;

      float  _Period;
      float  _Magnitude;
      float  _Scale;

    

      struct vin_vct {
        float4 vertex : POSITION;
        float4 color : COLOR;
        float2 texcoord : TEXCOORD0;
      };

      struct v2f_vct {
        float4 vertex : POSITION;
        fixed4 color : COLOR;
        float2 texcoord : TEXCOORD0;

        float4 worldPos : TEXCOORD1;
        float4 uvgrab : TEXCOORD2;
      };

      // Vertex function 
      v2f_vct vert (vin_vct v) {
        v2f_vct o;
        o.vertex = UnityObjectToClipPos(v.vertex);
        o.color = v.color;
        o.texcoord = v.texcoord;

        o.worldPos = mul(unity_ObjectToWorld, v.vertex);
        o.uvgrab = ComputeGrabScreenPos(o.vertex);
        
        return o;
      }

      // Fragment function
      fixed4 frag (v2f_vct i) : COLOR {
        /*
        Идея заключается в том, что синусоидальная функция используется для того, чтобы создать колебания.
        Этот эффект должен развиваться с течением времени; 
        для достижения этого эффекта искажение, генерируемое шейдером, зависит от текущего времени, 
        которое извлекается со встроенной переменной _Time.
        Переменная -_Period определяет период синусоиды, что означает, насколько быстро появляются волны

        Самый распространенный способ добавить случайное поведение в шейдеры - включить шум
        текстуры. Теперь проблема заключается в том, чтобы найти способ получить с текстуры, казалось бы, случайную
        позиции. Лучший способ избежать видимого синусоидального шаблона - использовать синус
        волны как смещение в UV-данных текстуры шума.

        Переменная _Scale определяет размер волн. 
        Это решение ближе к окончательной версии, но имеет серьезную проблему - если квад движется, 
        данные UV следуют за ним, и вы можете видеть волны воды после материала, а не привязываться к фону. 
        Чтобы решить эту проблему, мы должны использовать мировое положение текущего фрагмента 
        в качестве начальной позиции для UV-данных.
        */
        float sinT = sin(_Time.w / _Period);
        float2 distortion = float2 (tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(sinT, 0) ).r - 0.5,
                                    tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(0, sinT) ).r - 0.5
        );

        i.uvgrab.xy += distortion * _Magnitude;
        /*
        Чтобы использовать эту текстуру, нам нужны ее UV-данные. 
        Функция ComputeGrabScreenPos возвращает данные, которые мы можем использовать
        чтобы правильно отобразить текстуру захвата
        */
        fixed4 col = tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(i.uvgrab));
        return col * _Colour;
      }
    
      ENDCG
    } 
  }
}